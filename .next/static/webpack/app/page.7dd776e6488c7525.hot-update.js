"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/MapView.tsx":
/*!********************************!*\
  !*** ./components/MapView.tsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapView: function() { return /* binding */ MapView; },\n/* harmony export */   addSelectedRiverLine: function() { return /* binding */ addSelectedRiverLine; },\n/* harmony export */   clearSelectedRiverLine: function() { return /* binding */ clearSelectedRiverLine; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! maplibre-gl */ \"(app-pages-browser)/./node_modules/maplibre-gl/dist/maplibre-gl.js\");\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(maplibre_gl__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var maplibre_gl_dist_maplibre_gl_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! maplibre-gl/dist/maplibre-gl.css */ \"(app-pages-browser)/./node_modules/maplibre-gl/dist/maplibre-gl.css\");\n/* harmony import */ var _lib_river_focus_points__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/river-focus-points */ \"(app-pages-browser)/./lib/river-focus-points.ts\");\n/* harmony import */ var _MapControls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MapControls */ \"(app-pages-browser)/./components/MapControls.tsx\");\n/* __next_internal_client_entry_do_not_use__ addSelectedRiverLine,clearSelectedRiverLine,MapView auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nconst MONTANA_CENTER = [\n    -110.9,\n    46.9\n];\nconst DEFAULT_ZOOM = 5.2;\nconst FLY_ZOOM = 9.5;\nconst FLY_DURATION = 667;\nconst FLY_CURVE = 1.5;\nconst BITE_TIER_COLORS = {\n    HOT: \"#dc2626\",\n    GOOD: \"#16a34a\",\n    FAIR: \"#ca8a04\",\n    TOUGH: \"#64748b\"\n};\nconst RIVER_LINE_SOURCE = \"selected-river-source\";\nconst RIVER_LINE_LAYER = \"selected-river-line\";\nconst RIVERS_SOURCE = \"rivers-source\";\nconst UNCLUSTERED_LAYER = \"rivers-unclustered\";\nconst SELECTED_HALO_LAYER = \"rivers-selected-halo\";\nconst SELECTED_CORE_LAYER = \"rivers-selected-core\";\nfunction normalizeGeojson(g) {\n    if (!g) return null;\n    if (g.type === \"FeatureCollection\") return g;\n    if (g.type === \"Feature\") return g;\n    if (g.type === \"LineString\" || g.type === \"MultiLineString\") {\n        return {\n            type: \"Feature\",\n            properties: {},\n            geometry: g\n        };\n    }\n    return g;\n}\nfunction addSelectedRiverLine(map, geojson) {\n    const data = normalizeGeojson(geojson);\n    if (!data) return;\n    if (map.getLayer(RIVER_LINE_LAYER)) map.removeLayer(RIVER_LINE_LAYER);\n    if (map.getSource(RIVER_LINE_SOURCE)) map.removeSource(RIVER_LINE_SOURCE);\n    map.addSource(RIVER_LINE_SOURCE, {\n        type: \"geojson\",\n        data\n    });\n    map.addLayer({\n        id: RIVER_LINE_LAYER,\n        type: \"line\",\n        source: RIVER_LINE_SOURCE,\n        layout: {\n            \"line-join\": \"round\",\n            \"line-cap\": \"round\"\n        },\n        paint: {\n            \"line-color\": \"#00ffff\",\n            \"line-width\": 10,\n            \"line-opacity\": 0.9\n        }\n    });\n    try {\n        var _map_getStyle;\n        const layers = (_map_getStyle = map.getStyle()) === null || _map_getStyle === void 0 ? void 0 : _map_getStyle.layers;\n        if (layers === null || layers === void 0 ? void 0 : layers.length) map.moveLayer(RIVER_LINE_LAYER, layers[layers.length - 1].id);\n    } catch (e) {}\n}\nfunction clearSelectedRiverLine(map) {\n    if (map.getLayer(RIVER_LINE_LAYER)) {\n        map.removeLayer(RIVER_LINE_LAYER);\n    }\n    if (map.getSource(RIVER_LINE_SOURCE)) {\n        map.removeSource(RIVER_LINE_SOURCE);\n    }\n}\nfunction geojsonBbox(geojson) {\n    const coords = [];\n    const collect = (g)=>{\n        if (g.type === \"Point\") coords.push(g.coordinates);\n        else if (g.type === \"LineString\") for (const c of g.coordinates)coords.push(c);\n        else if (g.type === \"MultiLineString\") for (const line of g.coordinates)for (const c of line)coords.push(c);\n        else if (g.type === \"Polygon\") for (const ring of g.coordinates)for (const c of ring)coords.push(c);\n        else if (g.type === \"MultiPoint\") for (const c of g.coordinates)coords.push(c);\n    };\n    if (\"geometry\" in geojson && geojson.geometry) collect(geojson.geometry);\n    else if (\"coordinates\" in geojson) collect(geojson);\n    else if (\"features\" in geojson) {\n        for (const f of geojson.features)if (f.geometry) collect(f.geometry);\n    }\n    if (!coords.length) return null;\n    const lons = coords.map((c)=>c[0]);\n    const lats = coords.map((c)=>c[1]);\n    return [\n        Math.min(...lons),\n        Math.min(...lats),\n        Math.max(...lons),\n        Math.max(...lats)\n    ];\n}\nfunction riversToFeatureCollection(rivers) {\n    const features = [];\n    for (const river of rivers){\n        var _river_lat;\n        const lat = (_river_lat = river.lat) !== null && _river_lat !== void 0 ? _river_lat : river.latitude;\n        var _river_lng;\n        const lng = (_river_lng = river.lng) !== null && _river_lng !== void 0 ? _river_lng : river.longitude;\n        const coords = lat != null && lng != null ? [\n            lng,\n            lat\n        ] : _lib_river_focus_points__WEBPACK_IMPORTED_MODULE_4__.RIVER_FOCUS_POINTS[river.river_id];\n        if (!coords) continue;\n        var _river_bite_tier, _river_fishability_score_calc;\n        features.push({\n            type: \"Feature\",\n            geometry: {\n                type: \"Point\",\n                coordinates: coords\n            },\n            properties: {\n                river_id: river.river_id,\n                river_name: river.river_name,\n                bite_tier: (_river_bite_tier = river.bite_tier) !== null && _river_bite_tier !== void 0 ? _river_bite_tier : null,\n                fishability_score: (_river_fishability_score_calc = river.fishability_score_calc) !== null && _river_fishability_score_calc !== void 0 ? _river_fishability_score_calc : null\n            }\n        });\n    }\n    return {\n        type: \"FeatureCollection\",\n        features\n    };\n}\nfunction ensureRiverLayers(map, riversRef, onSelectRiverRef, hoverIdRef, selectedRiverIdRef) {\n    const rivers = riversRef.current;\n    const fc = riversToFeatureCollection(rivers);\n    const src = map.getSource(RIVERS_SOURCE);\n    if (!src) {\n        map.addSource(RIVERS_SOURCE, {\n            type: \"geojson\",\n            data: fc,\n            cluster: false,\n            generateId: true\n        });\n    } else {\n        try {\n            var _src_setData;\n            (_src_setData = src.setData) === null || _src_setData === void 0 ? void 0 : _src_setData.call(src, fc);\n        } catch (e) {\n        /* ignore */ }\n    }\n    if (!map.getLayer(UNCLUSTERED_LAYER)) {\n        map.addLayer({\n            id: UNCLUSTERED_LAYER,\n            type: \"circle\",\n            source: RIVERS_SOURCE,\n            filter: [\n                \"==\",\n                [\n                    \"geometry-type\"\n                ],\n                \"Point\"\n            ],\n            paint: {\n                \"circle-color\": [\n                    \"case\",\n                    [\n                        \"==\",\n                        [\n                            \"get\",\n                            \"bite_tier\"\n                        ],\n                        \"HOT\"\n                    ],\n                    BITE_TIER_COLORS.HOT,\n                    [\n                        \"==\",\n                        [\n                            \"get\",\n                            \"bite_tier\"\n                        ],\n                        \"GOOD\"\n                    ],\n                    BITE_TIER_COLORS.GOOD,\n                    [\n                        \"==\",\n                        [\n                            \"get\",\n                            \"bite_tier\"\n                        ],\n                        \"FAIR\"\n                    ],\n                    BITE_TIER_COLORS.FAIR,\n                    [\n                        \"==\",\n                        [\n                            \"get\",\n                            \"bite_tier\"\n                        ],\n                        \"TOUGH\"\n                    ],\n                    BITE_TIER_COLORS.TOUGH,\n                    \"#94a3b8\"\n                ],\n                \"circle-radius\": [\n                    \"case\",\n                    [\n                        \"boolean\",\n                        [\n                            \"feature-state\",\n                            \"hover\"\n                        ],\n                        false\n                    ],\n                    8,\n                    6\n                ],\n                \"circle-stroke-color\": \"rgba(255,255,255,0.92)\",\n                \"circle-stroke-width\": [\n                    \"case\",\n                    [\n                        \"boolean\",\n                        [\n                            \"feature-state\",\n                            \"hover\"\n                        ],\n                        false\n                    ],\n                    2.5,\n                    2\n                ],\n                \"circle-opacity\": 0.95\n            }\n        });\n    }\n    if (!map.getLayer(SELECTED_HALO_LAYER)) {\n        map.addLayer({\n            id: SELECTED_HALO_LAYER,\n            type: \"circle\",\n            source: RIVERS_SOURCE,\n            filter: [\n                \"==\",\n                [\n                    \"get\",\n                    \"river_id\"\n                ],\n                \"__none__\"\n            ],\n            paint: {\n                \"circle-color\": \"rgba(59, 130, 246, 0.35)\",\n                \"circle-radius\": 14\n            }\n        });\n    }\n    if (!map.getLayer(SELECTED_CORE_LAYER)) {\n        map.addLayer({\n            id: SELECTED_CORE_LAYER,\n            type: \"circle\",\n            source: RIVERS_SOURCE,\n            filter: [\n                \"==\",\n                [\n                    \"get\",\n                    \"river_id\"\n                ],\n                \"__none__\"\n            ],\n            paint: {\n                \"circle-color\": \"rgba(255,255,255,0.95)\",\n                \"circle-radius\": 6,\n                \"circle-stroke-color\": \"rgba(59, 130, 246, 0.95)\",\n                \"circle-stroke-width\": 2\n            }\n        });\n    }\n    if (!map.__mriHandlers) {\n        map.__mriHandlers = true;\n        map.on(\"click\", UNCLUSTERED_LAYER, (e)=>{\n            var _e_features, _f_properties;\n            const f = (_e_features = e.features) === null || _e_features === void 0 ? void 0 : _e_features[0];\n            const rid = f === null || f === void 0 ? void 0 : (_f_properties = f.properties) === null || _f_properties === void 0 ? void 0 : _f_properties.river_id;\n            if (!rid) return;\n            const river = riversRef.current.find((r)=>r.river_id === rid);\n            if (river) onSelectRiverRef.current(river);\n        });\n        map.on(\"mousemove\", UNCLUSTERED_LAYER, (e)=>{\n            var _e_features;\n            map.getCanvas().style.cursor = \"pointer\";\n            const f = (_e_features = e.features) === null || _e_features === void 0 ? void 0 : _e_features[0];\n            const id = f === null || f === void 0 ? void 0 : f.id;\n            if (id == null) return;\n            if (hoverIdRef.current != null && hoverIdRef.current !== id) {\n                try {\n                    map.setFeatureState({\n                        source: RIVERS_SOURCE,\n                        id: hoverIdRef.current\n                    }, {\n                        hover: false\n                    });\n                } catch (e) {}\n            }\n            hoverIdRef.current = id;\n            try {\n                map.setFeatureState({\n                    source: RIVERS_SOURCE,\n                    id: id\n                }, {\n                    hover: true\n                });\n            } catch (e) {}\n        });\n        map.on(\"mouseleave\", UNCLUSTERED_LAYER, ()=>{\n            map.getCanvas().style.cursor = \"\";\n            if (hoverIdRef.current != null) {\n                try {\n                    map.setFeatureState({\n                        source: RIVERS_SOURCE,\n                        id: hoverIdRef.current\n                    }, {\n                        hover: false\n                    });\n                } catch (e) {}\n            }\n            hoverIdRef.current = null;\n        });\n    }\n    var _selectedRiverIdRef_current;\n    const rid = (_selectedRiverIdRef_current = selectedRiverIdRef.current) !== null && _selectedRiverIdRef_current !== void 0 ? _selectedRiverIdRef_current : \"__none__\";\n    if (map.getLayer(SELECTED_HALO_LAYER) && map.getLayer(SELECTED_CORE_LAYER)) {\n        try {\n            map.setFilter(SELECTED_HALO_LAYER, [\n                \"==\",\n                [\n                    \"get\",\n                    \"river_id\"\n                ],\n                rid\n            ]);\n            map.setFilter(SELECTED_CORE_LAYER, [\n                \"==\",\n                [\n                    \"get\",\n                    \"river_id\"\n                ],\n                rid\n            ]);\n        } catch (e) {}\n    }\n}\nfunction MapView(param) {\n    let { rivers, selectedRiver, selectedRiverId, selectedRiverGeojson, onSelectRiver, className, initialStyleUrl, onMapReady } = param;\n    _s();\n    const mapContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastFlownRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const hoverIdRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const riversRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(rivers);\n    const onSelectRiverRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(onSelectRiver);\n    const selectedRiverIdRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(selectedRiverId);\n    riversRef.current = rivers;\n    onSelectRiverRef.current = onSelectRiver;\n    selectedRiverIdRef.current = selectedRiverId;\n    const [mapReady, setMapReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const initMap = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!mapContainerRef.current) return;\n        const map = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Map)({\n            container: mapContainerRef.current,\n            style: initialStyleUrl !== null && initialStyleUrl !== void 0 ? initialStyleUrl : \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n            center: MONTANA_CENTER,\n            zoom: DEFAULT_ZOOM,\n            pitch: 22,\n            bearing: -5\n        });\n        map.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().NavigationControl)(), \"top-right\");\n        mapRef.current = map;\n        map.on(\"load\", ()=>{\n            map.resize();\n            setMapReady(true);\n            onMapReady === null || onMapReady === void 0 ? void 0 : onMapReady(map);\n            requestAnimationFrame(()=>map.resize());\n            setTimeout(()=>map.resize(), 100);\n            try {\n                ensureRiverLayers(map, riversRef, onSelectRiverRef, hoverIdRef, selectedRiverIdRef);\n            } catch (e) {}\n        });\n    }, [\n        onMapReady\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        initMap();\n        return ()=>{\n            var _mapRef_current;\n            (_mapRef_current = mapRef.current) === null || _mapRef_current === void 0 ? void 0 : _mapRef_current.remove();\n            mapRef.current = null;\n            lastFlownRef.current = null;\n        };\n    }, [\n        initMap\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapRef.current;\n        if (!map || !mapContainerRef.current) return;\n        const handleResize = ()=>map.resize();\n        window.addEventListener(\"resize\", handleResize);\n        const resizeObserver = new ResizeObserver(()=>map.resize());\n        resizeObserver.observe(mapContainerRef.current);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            resizeObserver.disconnect();\n        };\n    }, [\n        mapReady\n    ]);\n    const riversKey = rivers.map((r)=>r.river_id).join(\",\");\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapRef.current;\n        if (!map || !mapReady) return;\n        if (typeof map.isStyleLoaded === \"function\" && !map.isStyleLoaded()) return;\n        try {\n            ensureRiverLayers(map, riversRef, onSelectRiverRef, hoverIdRef, selectedRiverIdRef);\n        } catch (e) {}\n        const fc = riversToFeatureCollection(rivers);\n        if (fc.features.length) {\n            const bounds = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().LngLatBounds)(fc.features[0].geometry.coordinates, fc.features[0].geometry.coordinates);\n            for (const f of fc.features)bounds.extend(f.geometry.coordinates);\n            map.fitBounds(bounds, {\n                padding: 60,\n                duration: 450\n            });\n        }\n    }, [\n        riversKey,\n        mapReady,\n        rivers,\n        onSelectRiver\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapRef.current;\n        if (!map || !mapReady) return;\n        if (!map.getLayer(SELECTED_HALO_LAYER) || !map.getLayer(SELECTED_CORE_LAYER)) return;\n        const rid = selectedRiverId !== null && selectedRiverId !== void 0 ? selectedRiverId : \"__none__\";\n        try {\n            map.setFilter(SELECTED_HALO_LAYER, [\n                \"==\",\n                [\n                    \"get\",\n                    \"river_id\"\n                ],\n                rid\n            ]);\n            map.setFilter(SELECTED_CORE_LAYER, [\n                \"==\",\n                [\n                    \"get\",\n                    \"river_id\"\n                ],\n                rid\n            ]);\n        } catch (e) {\n        /* ignore */ }\n    }, [\n        selectedRiverId,\n        mapReady\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapRef.current;\n        if (!map || !mapReady) return;\n        if (typeof map.isStyleLoaded === \"function\" && !map.isStyleLoaded()) return;\n        clearSelectedRiverLine(map);\n        console.log(\"[selectedRiverGeojson]\", selectedRiverGeojson);\n        if (!selectedRiverId) {\n            lastFlownRef.current = null;\n            return;\n        }\n        if (lastFlownRef.current === selectedRiverId) return;\n        lastFlownRef.current = selectedRiverId;\n        const focus = (selectedRiver === null || selectedRiver === void 0 ? void 0 : selectedRiver.lat) != null && (selectedRiver === null || selectedRiver === void 0 ? void 0 : selectedRiver.lng) != null ? [\n            selectedRiver.lng,\n            selectedRiver.lat\n        ] : _lib_river_focus_points__WEBPACK_IMPORTED_MODULE_4__.RIVER_FOCUS_POINTS[selectedRiverId];\n        if (selectedRiverGeojson) {\n            addSelectedRiverLine(map, selectedRiverGeojson);\n            const bbox = geojsonBbox(selectedRiverGeojson);\n            if (bbox && map.fitBounds) {\n                map.fitBounds([\n                    [\n                        bbox[0],\n                        bbox[1]\n                    ],\n                    [\n                        bbox[2],\n                        bbox[3]\n                    ]\n                ], {\n                    padding: 60,\n                    duration: 700,\n                    essential: true\n                });\n                return;\n            }\n        }\n        if (focus) {\n            map.flyTo({\n                center: focus,\n                zoom: FLY_ZOOM,\n                duration: FLY_DURATION,\n                curve: FLY_CURVE,\n                essential: true\n            });\n        }\n    }, [\n        selectedRiverId,\n        selectedRiverGeojson,\n        selectedRiver,\n        mapReady\n    ]);\n    // Re-apply selected river line when basemap changes (map.setStyle wipes custom layers)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapRef.current;\n        if (!map || !mapReady) return;\n        const reapply = ()=>{\n            try {\n                clearSelectedRiverLine(map);\n                if (selectedRiverGeojson) addSelectedRiverLine(map, selectedRiverGeojson);\n            } catch (e) {\n                console.warn(\"[MapView] reapply selected river line failed\", e);\n            }\n        };\n        map.on(\"load\", reapply);\n        return ()=>{\n            map.off(\"load\", reapply);\n        };\n    }, [\n        mapReady,\n        selectedRiverGeojson\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"map\",\n        ref: mapContainerRef,\n        className: \"absolute inset-0 w-full h-full min-h-0 [&_.maplibregl-marker]:cursor-pointer \".concat(className !== null && className !== void 0 ? className : \"\").trim(),\n        \"aria-label\": \"Montana river map\",\n        children: mapReady && mapRef.current && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MapControls__WEBPACK_IMPORTED_MODULE_5__.MapControls, {\n            map: mapRef.current\n        }, void 0, false, {\n            fileName: \"/Users/daniel/montana-river-v2/components/MapView.tsx\",\n            lineNumber: 431,\n            columnNumber: 38\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/daniel/montana-river-v2/components/MapView.tsx\",\n        lineNumber: 425,\n        columnNumber: 5\n    }, this);\n}\n_s(MapView, \"hA/i5qZ5EaPdSeUSDeXYVykm7+o=\");\n_c = MapView;\nvar _c;\n$RefreshReg$(_c, \"MapView\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTWFwVmlldy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUV3RTtBQUNuQztBQUNLO0FBRW9CO0FBQ2xCO0FBRTVDLE1BQU1RLGlCQUFtQztJQUFDLENBQUM7SUFBTztDQUFLO0FBQ3ZELE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLFlBQVk7QUFFbEIsTUFBTUMsbUJBQTZDO0lBQ2pEQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPO0FBQ1Q7QUFhQSxNQUFNQyxvQkFBb0I7QUFDMUIsTUFBTUMsbUJBQW1CO0FBRXpCLE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxvQkFBb0I7QUFDMUIsTUFBTUMsc0JBQXNCO0FBQzVCLE1BQU1DLHNCQUFzQjtBQUU1QixTQUFTQyxpQkFBaUJDLENBQU07SUFDOUIsSUFBSSxDQUFDQSxHQUFHLE9BQU87SUFDZixJQUFJQSxFQUFFQyxJQUFJLEtBQUsscUJBQXFCLE9BQU9EO0lBQzNDLElBQUlBLEVBQUVDLElBQUksS0FBSyxXQUFXLE9BQU9EO0lBQ2pDLElBQUlBLEVBQUVDLElBQUksS0FBSyxnQkFBZ0JELEVBQUVDLElBQUksS0FBSyxtQkFBbUI7UUFDM0QsT0FBTztZQUFFQSxNQUFNO1lBQVdDLFlBQVksQ0FBQztZQUFHQyxVQUFVSDtRQUFFO0lBQ3hEO0lBQ0EsT0FBT0E7QUFDVDtBQUVPLFNBQVNJLHFCQUFxQkMsR0FBUSxFQUFFQyxPQUFZO0lBQ3pELE1BQU1DLE9BQU9SLGlCQUFpQk87SUFDOUIsSUFBSSxDQUFDQyxNQUFNO0lBRVgsSUFBSUYsSUFBSUcsUUFBUSxDQUFDZCxtQkFBbUJXLElBQUlJLFdBQVcsQ0FBQ2Y7SUFDcEQsSUFBSVcsSUFBSUssU0FBUyxDQUFDakIsb0JBQW9CWSxJQUFJTSxZQUFZLENBQUNsQjtJQUV2RFksSUFBSU8sU0FBUyxDQUFDbkIsbUJB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WUFDYjtRQUNGO0lBQ0YsR0FBRztRQUFDN0M7UUFBaUJDO1FBQXNCRjtRQUFlVTtLQUFTO0lBRW5FLHVGQUF1RjtJQUN2RjdHLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTTZCLE1BQU04RSxPQUFPNUIsT0FBTztRQUMxQixJQUFJLENBQUNsRCxPQUFPLENBQUNnRixVQUFVO1FBRXZCLE1BQU11QyxVQUFVO1lBQ2QsSUFBSTtnQkFDRnRHLHVCQUF1QmpCO2dCQUN2QixJQUFJd0Usc0JBQXNCekUscUJBQXFCQyxLQUFLd0U7WUFDdEQsRUFBRSxPQUFPYixHQUFHO2dCQUNWcUQsUUFBUVEsSUFBSSxDQUFDLGdEQUFnRDdEO1lBQy9EO1FBQ0Y7UUFFQTNELElBQUkwRCxFQUFFLENBQUMsUUFBUTZEO1FBQ2YsT0FBTztZQUNMdkgsSUFBSXlILEdBQUcsQ0FBQyxRQUFRRjtRQUNsQjtJQUNGLEdBQUc7UUFBQ3ZDO1FBQVVSO0tBQXFCO0lBRW5DLHFCQUNFLDhEQUFDa0Q7UUFDQ2pILElBQUc7UUFDSGtILEtBQUs5QztRQUNMSCxXQUFXLGdGQUFnRyxPQUFoQkEsc0JBQUFBLHVCQUFBQSxZQUFhLElBQUtrRCxJQUFJO1FBQ2pIQyxjQUFXO2tCQUVWN0MsWUFBWUYsT0FBTzVCLE9BQU8sa0JBQUksOERBQUN6RSxxREFBV0E7WUFBQ3VCLEtBQUs4RSxPQUFPNUIsT0FBTzs7Ozs7Ozs7Ozs7QUFHckU7R0ExTGdCbUI7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9NYXBWaWV3LnRzeD8wNjU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IG1hcGxpYnJlZ2wgZnJvbSBcIm1hcGxpYnJlLWdsXCI7XG5pbXBvcnQgXCJtYXBsaWJyZS1nbC9kaXN0L21hcGxpYnJlLWdsLmNzc1wiO1xuaW1wb3J0IHR5cGUgeyBGaXNoYWJpbGl0eVJvdywgQml0ZVRpZXIgfSBmcm9tIFwiQC9saWIvdHlwZXNcIjtcbmltcG9ydCB7IFJJVkVSX0ZPQ1VTX1BPSU5UUyB9IGZyb20gXCJAL2xpYi9yaXZlci1mb2N1cy1wb2ludHNcIjtcbmltcG9ydCB7IE1hcENvbnRyb2xzIH0gZnJvbSBcIi4vTWFwQ29udHJvbHNcIjtcblxuY29uc3QgTU9OVEFOQV9DRU5URVI6IFtudW1iZXIsIG51bWJlcl0gPSBbLTExMC45LCA0Ni45XTtcbmNvbnN0IERFRkFVTFRfWk9PTSA9IDUuMjtcbmNvbnN0IEZMWV9aT09NID0gOS41O1xuY29uc3QgRkxZX0RVUkFUSU9OID0gNjY3O1xuY29uc3QgRkxZX0NVUlZFID0gMS41O1xuXG5jb25zdCBCSVRFX1RJRVJfQ09MT1JTOiBSZWNvcmQ8Qml0ZVRpZXIsIHN0cmluZz4gPSB7XG4gIEhPVDogXCIjZGMyNjI2XCIsXG4gIEdPT0Q6IFwiIzE2YTM0YVwiLFxuICBGQUlSOiBcIiNjYThhMDRcIixcbiAgVE9VR0g6IFwiIzY0NzQ4YlwiLFxufTtcblxuaW50ZXJmYWNlIE1hcFZpZXdQcm9wcyB7XG4gIHJpdmVyczogRmlzaGFiaWxpdHlSb3dbXTtcbiAgc2VsZWN0ZWRSaXZlcjogRmlzaGFiaWxpdHlSb3cgfCBudWxsO1xuICBzZWxlY3RlZFJpdmVySWQ6IHN0cmluZyB8IG51bGw7XG4gIHNlbGVjdGVkUml2ZXJHZW9qc29uOiBHZW9KU09OLkdlb0pTT04gfCBudWxsO1xuICBvblNlbGVjdFJpdmVyOiAocml2ZXI6IEZpc2hhYmlsaXR5Um93KSA9PiB2b2lkO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIGluaXRpYWxTdHlsZVVybD86IHN0cmluZztcbiAgb25NYXBSZWFkeT86IChtYXA6IG1hcGxpYnJlZ2wuTWFwKSA9PiB2b2lkO1xufVxuXG5jb25zdCBSSVZFUl9MSU5FX1NPVVJDRSA9IFwic2VsZWN0ZWQtcml2ZXItc291cmNlXCI7XG5jb25zdCBSSVZFUl9MSU5FX0xBWUVSID0gXCJzZWxlY3RlZC1yaXZlci1saW5lXCI7XG5cbmNvbnN0IFJJVkVSU19TT1VSQ0UgPSBcInJpdmVycy1zb3VyY2VcIjtcbmNvbnN0IFVOQ0xVU1RFUkVEX0xBWUVSID0gXCJyaXZlcnMtdW5jbHVzdGVyZWRcIjtcbmNvbnN0IFNFTEVDVEVEX0hBTE9fTEFZRVIgPSBcInJpdmVycy1zZWxlY3RlZC1oYWxvXCI7XG5jb25zdCBTRUxFQ1RFRF9DT1JFX0xBWUVSID0gXCJyaXZlcnMtc2VsZWN0ZWQtY29yZVwiO1xuXG5mdW5jdGlvbiBub3JtYWxpemVHZW9qc29uKGc6IGFueSk6IGFueSB7XG4gIGlmICghZykgcmV0dXJuIG51bGw7XG4gIGlmIChnLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikgcmV0dXJuIGc7XG4gIGlmIChnLnR5cGUgPT09IFwiRmVhdHVyZVwiKSByZXR1cm4gZztcbiAgaWYgKGcudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIgfHwgZy50eXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJGZWF0dXJlXCIsIHByb3BlcnRpZXM6IHt9LCBnZW9tZXRyeTogZyB9O1xuICB9XG4gIHJldHVybiBnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkU2VsZWN0ZWRSaXZlckxpbmUobWFwOiBhbnksIGdlb2pzb246IGFueSk6IHZvaWQge1xuICBjb25zdCBkYXRhID0gbm9ybWFsaXplR2VvanNvbihnZW9qc29uKTtcbiAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgaWYgKG1hcC5nZXRMYXllcihSSVZFUl9MSU5FX0xBWUVSKSkgbWFwLnJlbW92ZUxheWVyKFJJVkVSX0xJTkVfTEFZRVIpO1xuICBpZiAobWFwLmdldFNvdXJjZShSSVZFUl9MSU5FX1NPVVJDRSkpIG1hcC5yZW1vdmVTb3VyY2UoUklWRVJfTElORV9TT1VSQ0UpO1xuXG4gIG1hcC5hZGRTb3VyY2UoUklWRVJfTElORV9TT1VSQ0UsIHsgdHlwZTogXCJnZW9qc29uXCIsIGRhdGEgfSk7XG5cbiAgbWFwLmFkZExheWVyKHtcbiAgICBpZDogUklWRVJfTElORV9MQVlFUixcbiAgICB0eXBlOiBcImxpbmVcIixcbiAgICBzb3VyY2U6IFJJVkVSX0xJTkVfU09VUkNFLFxuICAgIGxheW91dDogeyBcImxpbmUtam9pblwiOiBcInJvdW5kXCIsIFwibGluZS1jYXBcIjogXCJyb3VuZFwiIH0sXG4gICAgcGFpbnQ6IHtcbiAgICAgIFwibGluZS1jb2xvclwiOiBcIiMwMGZmZmZcIixcbiAgICAgIFwibGluZS13aWR0aFwiOiAxMCxcbiAgICAgIFwibGluZS1vcGFjaXR5XCI6IDAuOSxcbiAgICB9LFxuICB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IGxheWVycyA9IG1hcC5nZXRTdHlsZSgpPy5sYXllcnM7XG4gICAgaWYgKGxheWVycz8ubGVuZ3RoKSBtYXAubW92ZUxheWVyKFJJVkVSX0xJTkVfTEFZRVIsIGxheWVyc1tsYXllcnMubGVuZ3RoIC0gMV0uaWQpO1xuICB9IGNhdGNoIHt9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclNlbGVjdGVkUml2ZXJMaW5lKG1hcDogYW55KTogdm9pZCB7XG4gIGlmIChtYXAuZ2V0TGF5ZXIoUklWRVJfTElORV9MQVlFUikpIHtcbiAgICBtYXAucmVtb3ZlTGF5ZXIoUklWRVJfTElORV9MQVlFUik7XG4gIH1cbiAgaWYgKG1hcC5nZXRTb3VyY2UoUklWRVJfTElORV9TT1VSQ0UpKSB7XG4gICAgbWFwLnJlbW92ZVNvdXJjZShSSVZFUl9MSU5FX1NPVVJDRSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VvanNvbkJib3goZ2VvanNvbjogR2VvSlNPTi5HZW9KU09OKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBudWxsIHtcbiAgY29uc3QgY29vcmRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcbiAgY29uc3QgY29sbGVjdCA9IChnOiBHZW9KU09OLkdlb21ldHJ5KSA9PiB7XG4gICAgaWYgKGcudHlwZSA9PT0gXCJQb2ludFwiKSBjb29yZHMucHVzaChnLmNvb3JkaW5hdGVzIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgIGVsc2UgaWYgKGcudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIGZvciAoY29uc3QgYyBvZiBnLmNvb3JkaW5hdGVzKSBjb29yZHMucHVzaChjIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgIGVsc2UgaWYgKGcudHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIikgZm9yIChjb25zdCBsaW5lIG9mIGcuY29vcmRpbmF0ZXMpIGZvciAoY29uc3QgYyBvZiBsaW5lKSBjb29yZHMucHVzaChjIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgIGVsc2UgaWYgKGcudHlwZSA9PT0gXCJQb2x5Z29uXCIpIGZvciAoY29uc3QgcmluZyBvZiBnLmNvb3JkaW5hdGVzKSBmb3IgKGNvbnN0IGMgb2YgcmluZykgY29vcmRzLnB1c2goYyBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICBlbHNlIGlmIChnLnR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSBmb3IgKGNvbnN0IGMgb2YgZy5jb29yZGluYXRlcykgY29vcmRzLnB1c2goYyBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgfTtcbiAgaWYgKFwiZ2VvbWV0cnlcIiBpbiBnZW9qc29uICYmIGdlb2pzb24uZ2VvbWV0cnkpIGNvbGxlY3QoZ2VvanNvbi5nZW9tZXRyeSk7XG4gIGVsc2UgaWYgKFwiY29vcmRpbmF0ZXNcIiBpbiBnZW9qc29uKSBjb2xsZWN0KGdlb2pzb24gYXMgR2VvSlNPTi5HZW9tZXRyeSk7XG4gIGVsc2UgaWYgKFwiZmVhdHVyZXNcIiBpbiBnZW9qc29uKSBmb3IgKGNvbnN0IGYgb2YgZ2VvanNvbi5mZWF0dXJlcykgaWYgKGYuZ2VvbWV0cnkpIGNvbGxlY3QoZi5nZW9tZXRyeSk7XG4gIGlmICghY29vcmRzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGxvbnMgPSBjb29yZHMubWFwKChjKSA9PiBjWzBdKTtcbiAgY29uc3QgbGF0cyA9IGNvb3Jkcy5tYXAoKGMpID0+IGNbMV0pO1xuICByZXR1cm4gW01hdGgubWluKC4uLmxvbnMpLCBNYXRoLm1pbiguLi5sYXRzKSwgTWF0aC5tYXgoLi4ubG9ucyksIE1hdGgubWF4KC4uLmxhdHMpXTtcbn1cblxuZnVuY3Rpb24gcml2ZXJzVG9GZWF0dXJlQ29sbGVjdGlvbihyaXZlcnM6IEZpc2hhYmlsaXR5Um93W10pIHtcbiAgY29uc3QgZmVhdHVyZXM6IEdlb0pTT04uRmVhdHVyZTxHZW9KU09OLlBvaW50LCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj5bXSA9IFtdO1xuXG4gIGZvciAoY29uc3Qgcml2ZXIgb2Ygcml2ZXJzKSB7XG4gICAgY29uc3QgbGF0ID0gcml2ZXIubGF0ID8/IChyaXZlciBhcyB7IGxhdGl0dWRlPzogbnVtYmVyIH0pLmxhdGl0dWRlO1xuICAgIGNvbnN0IGxuZyA9IHJpdmVyLmxuZyA/PyAocml2ZXIgYXMgeyBsb25naXR1ZGU/OiBudW1iZXIgfSkubG9uZ2l0dWRlO1xuICAgIGNvbnN0IGNvb3JkczogW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZCA9XG4gICAgICBsYXQgIT0gbnVsbCAmJiBsbmcgIT0gbnVsbCA/IFtsbmcsIGxhdF0gOiBSSVZFUl9GT0NVU19QT0lOVFNbcml2ZXIucml2ZXJfaWRdO1xuXG4gICAgaWYgKCFjb29yZHMpIGNvbnRpbnVlO1xuXG4gICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgIGdlb21ldHJ5OiB7IHR5cGU6IFwiUG9pbnRcIiwgY29vcmRpbmF0ZXM6IGNvb3JkcyB9LFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByaXZlcl9pZDogcml2ZXIucml2ZXJfaWQsXG4gICAgICAgIHJpdmVyX25hbWU6IHJpdmVyLnJpdmVyX25hbWUsXG4gICAgICAgIGJpdGVfdGllcjogcml2ZXIuYml0ZV90aWVyID8/IG51bGwsXG4gICAgICAgIGZpc2hhYmlsaXR5X3Njb3JlOiByaXZlci5maXNoYWJpbGl0eV9zY29yZV9jYWxjID8/IG51bGwsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiIGFzIGNvbnN0LCBmZWF0dXJlcyB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVSaXZlckxheWVycyhcbiAgbWFwOiBtYXBsaWJyZWdsLk1hcCxcbiAgcml2ZXJzUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEZpc2hhYmlsaXR5Um93W10+LFxuICBvblNlbGVjdFJpdmVyUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PChyaXZlcjogRmlzaGFiaWxpdHlSb3cpID0+IHZvaWQ+LFxuICBob3ZlcklkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PG51bWJlciB8IHN0cmluZyB8IG51bGw+LFxuICBzZWxlY3RlZFJpdmVySWRSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8c3RyaW5nIHwgbnVsbD5cbikge1xuICBjb25zdCByaXZlcnMgPSByaXZlcnNSZWYuY3VycmVudDtcbiAgY29uc3QgZmMgPSByaXZlcnNUb0ZlYXR1cmVDb2xsZWN0aW9uKHJpdmVycyk7XG5cbiAgY29uc3Qgc3JjID0gbWFwLmdldFNvdXJjZShSSVZFUlNfU09VUkNFKSBhcyB7IHNldERhdGE/OiAoZDogR2VvSlNPTi5GZWF0dXJlQ29sbGVjdGlvbikgPT4gdm9pZCB9IHwgdW5kZWZpbmVkO1xuICBpZiAoIXNyYykge1xuICAgIG1hcC5hZGRTb3VyY2UoUklWRVJTX1NPVVJDRSwge1xuICAgICAgdHlwZTogXCJnZW9qc29uXCIsXG4gICAgICBkYXRhOiBmYyxcbiAgICAgIGNsdXN0ZXI6IGZhbHNlLFxuICAgICAgZ2VuZXJhdGVJZDogdHJ1ZSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgc3JjLnNldERhdGE/LihmYyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvKiBpZ25vcmUgKi9cbiAgICB9XG4gIH1cblxuICBpZiAoIW1hcC5nZXRMYXllcihVTkNMVVNURVJFRF9MQVlFUikpIHtcbiAgICBtYXAuYWRkTGF5ZXIoe1xuICAgICAgaWQ6IFVOQ0xVU1RFUkVEX0xBWUVSLFxuICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgIHNvdXJjZTogUklWRVJTX1NPVVJDRSxcbiAgICAgIGZpbHRlcjogW1wiPT1cIiwgW1wiZ2VvbWV0cnktdHlwZVwiXSwgXCJQb2ludFwiXSxcbiAgICAgIHBhaW50OiB7XG4gICAgICAgIFwiY2lyY2xlLWNvbG9yXCI6IFtcbiAgICAgICAgICBcImNhc2VcIixcbiAgICAgICAgICBbXCI9PVwiLCBbXCJnZXRcIiwgXCJiaXRlX3RpZXJcIl0sIFwiSE9UXCJdLCBCSVRFX1RJRVJfQ09MT1JTLkhPVCxcbiAgICAgICAgICBbXCI9PVwiLCBbXCJnZXRcIiwgXCJiaXRlX3RpZXJcIl0sIFwiR09PRFwiXSwgQklURV9USUVSX0NPTE9SUy5HT09ELFxuICAgICAgICAgIFtcIj09XCIsIFtcImdldFwiLCBcImJpdGVfdGllclwiXSwgXCJGQUlSXCJdLCBCSVRFX1RJRVJfQ09MT1JTLkZBSVIsXG4gICAgICAgICAgW1wiPT1cIiwgW1wiZ2V0XCIsIFwiYml0ZV90aWVyXCJdLCBcIlRPVUdIXCJdLCBCSVRFX1RJRVJfQ09MT1JTLlRPVUdILFxuICAgICAgICAgIFwiIzk0YTNiOFwiLFxuICAgICAgICBdLFxuICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjogW1wiY2FzZVwiLCBbXCJib29sZWFuXCIsIFtcImZlYXR1cmUtc3RhdGVcIiwgXCJob3ZlclwiXSwgZmFsc2VdLCA4LCA2XSxcbiAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLWNvbG9yXCI6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjkyKVwiLFxuICAgICAgICBcImNpcmNsZS1zdHJva2Utd2lkdGhcIjogW1wiY2FzZVwiLCBbXCJib29sZWFuXCIsIFtcImZlYXR1cmUtc3RhdGVcIiwgXCJob3ZlclwiXSwgZmFsc2VdLCAyLjUsIDJdLFxuICAgICAgICBcImNpcmNsZS1vcGFjaXR5XCI6IDAuOTUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG4gIGlmICghbWFwLmdldExheWVyKFNFTEVDVEVEX0hBTE9fTEFZRVIpKSB7XG4gICAgbWFwLmFkZExheWVyKHtcbiAgICAgIGlkOiBTRUxFQ1RFRF9IQUxPX0xBWUVSLFxuICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgIHNvdXJjZTogUklWRVJTX1NPVVJDRSxcbiAgICAgIGZpbHRlcjogW1wiPT1cIiwgW1wiZ2V0XCIsIFwicml2ZXJfaWRcIl0sIFwiX19ub25lX19cIl0sXG4gICAgICBwYWludDogeyBcImNpcmNsZS1jb2xvclwiOiBcInJnYmEoNTksIDEzMCwgMjQ2LCAwLjM1KVwiLCBcImNpcmNsZS1yYWRpdXNcIjogMTQgfSxcbiAgICB9KTtcbiAgfVxuICBpZiAoIW1hcC5nZXRMYXllcihTRUxFQ1RFRF9DT1JFX0xBWUVSKSkge1xuICAgIG1hcC5hZGRMYXllcih7XG4gICAgICBpZDogU0VMRUNURURfQ09SRV9MQVlFUixcbiAgICAgIHR5cGU6IFwiY2lyY2xlXCIsXG4gICAgICBzb3VyY2U6IFJJVkVSU19TT1VSQ0UsXG4gICAgICBmaWx0ZXI6IFtcIj09XCIsIFtcImdldFwiLCBcInJpdmVyX2lkXCJdLCBcIl9fbm9uZV9fXCJdLFxuICAgICAgcGFpbnQ6IHtcbiAgICAgICAgXCJjaXJjbGUtY29sb3JcIjogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuOTUpXCIsXG4gICAgICAgIFwiY2lyY2xlLXJhZGl1c1wiOiA2LFxuICAgICAgICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjogXCJyZ2JhKDU5LCAxMzAsIDI0NiwgMC45NSlcIixcbiAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCI6IDIsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCEobWFwIGFzIGFueSkuX19tcmlIYW5kbGVycykge1xuICAgIChtYXAgYXMgYW55KS5fX21yaUhhbmRsZXJzID0gdHJ1ZTtcbiAgICBtYXAub24oXCJjbGlja1wiLCBVTkNMVVNURVJFRF9MQVlFUiwgKGU6IG1hcGxpYnJlZ2wuTWFwTGF5ZXJNb3VzZUV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBmID0gZS5mZWF0dXJlcz8uWzBdO1xuICAgICAgY29uc3QgcmlkID0gZj8ucHJvcGVydGllcz8ucml2ZXJfaWQgYXMgc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgaWYgKCFyaWQpIHJldHVybjtcbiAgICAgIGNvbnN0IHJpdmVyID0gcml2ZXJzUmVmLmN1cnJlbnQuZmluZCgocikgPT4gci5yaXZlcl9pZCA9PT0gcmlkKTtcbiAgICAgIGlmIChyaXZlcikgb25TZWxlY3RSaXZlclJlZi5jdXJyZW50KHJpdmVyKTtcbiAgICB9KTtcbiAgICBtYXAub24oXCJtb3VzZW1vdmVcIiwgVU5DTFVTVEVSRURfTEFZRVIsIChlOiBtYXBsaWJyZWdsLk1hcExheWVyTW91c2VFdmVudCkgPT4ge1xuICAgICAgbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgY29uc3QgZiA9IGUuZmVhdHVyZXM/LlswXTtcbiAgICAgIGNvbnN0IGlkID0gZj8uaWQ7XG4gICAgICBpZiAoaWQgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKGhvdmVySWRSZWYuY3VycmVudCAhPSBudWxsICYmIGhvdmVySWRSZWYuY3VycmVudCAhPT0gaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtYXAuc2V0RmVhdHVyZVN0YXRlKHsgc291cmNlOiBSSVZFUlNfU09VUkNFLCBpZDogaG92ZXJJZFJlZi5jdXJyZW50IGFzIG51bWJlciB9LCB7IGhvdmVyOiBmYWxzZSB9KTtcbiAgICAgICAgfSBjYXRjaCB7IC8qIGlnbm9yZSAqLyB9XG4gICAgICB9XG4gICAgICBob3ZlcklkUmVmLmN1cnJlbnQgPSBpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1hcC5zZXRGZWF0dXJlU3RhdGUoeyBzb3VyY2U6IFJJVkVSU19TT1VSQ0UsIGlkOiBpZCBhcyBudW1iZXIgfSwgeyBob3ZlcjogdHJ1ZSB9KTtcbiAgICAgIH0gY2F0Y2ggeyAvKiBpZ25vcmUgKi8gfVxuICAgIH0pO1xuICAgIG1hcC5vbihcIm1vdXNlbGVhdmVcIiwgVU5DTFVTVEVSRURfTEFZRVIsICgpID0+IHtcbiAgICAgIG1hcC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSBcIlwiO1xuICAgICAgaWYgKGhvdmVySWRSZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWFwLnNldEZlYXR1cmVTdGF0ZSh7IHNvdXJjZTogUklWRVJTX1NPVVJDRSwgaWQ6IGhvdmVySWRSZWYuY3VycmVudCBhcyBudW1iZXIgfSwgeyBob3ZlcjogZmFsc2UgfSk7XG4gICAgICAgIH0gY2F0Y2ggeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgfVxuICAgICAgaG92ZXJJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHJpZCA9IHNlbGVjdGVkUml2ZXJJZFJlZi5jdXJyZW50ID8/IFwiX19ub25lX19cIjtcbiAgaWYgKG1hcC5nZXRMYXllcihTRUxFQ1RFRF9IQUxPX0xBWUVSKSAmJiBtYXAuZ2V0TGF5ZXIoU0VMRUNURURfQ09SRV9MQVlFUikpIHtcbiAgICB0cnkge1xuICAgICAgbWFwLnNldEZpbHRlcihTRUxFQ1RFRF9IQUxPX0xBWUVSLCBbXCI9PVwiLCBbXCJnZXRcIiwgXCJyaXZlcl9pZFwiXSwgcmlkXSk7XG4gICAgICBtYXAuc2V0RmlsdGVyKFNFTEVDVEVEX0NPUkVfTEFZRVIsIFtcIj09XCIsIFtcImdldFwiLCBcInJpdmVyX2lkXCJdLCByaWRdKTtcbiAgICB9IGNhdGNoIHsgLyogaWdub3JlICovIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gTWFwVmlldyh7XG4gIHJpdmVycyxcbiAgc2VsZWN0ZWRSaXZlcixcbiAgc2VsZWN0ZWRSaXZlcklkLFxuICBzZWxlY3RlZFJpdmVyR2VvanNvbixcbiAgb25TZWxlY3RSaXZlcixcbiAgY2xhc3NOYW1lLFxuICBpbml0aWFsU3R5bGVVcmwsXG4gIG9uTWFwUmVhZHksXG59OiBNYXBWaWV3UHJvcHMpIHtcbiAgY29uc3QgbWFwQ29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgbWFwUmVmID0gdXNlUmVmPG1hcGxpYnJlZ2wuTWFwIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGxhc3RGbG93blJlZiA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgaG92ZXJJZFJlZiA9IHVzZVJlZjxudW1iZXIgfCBzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3Qgcml2ZXJzUmVmID0gdXNlUmVmKHJpdmVycyk7XG4gIGNvbnN0IG9uU2VsZWN0Uml2ZXJSZWYgPSB1c2VSZWYob25TZWxlY3RSaXZlcik7XG4gIGNvbnN0IHNlbGVjdGVkUml2ZXJJZFJlZiA9IHVzZVJlZihzZWxlY3RlZFJpdmVySWQpO1xuICByaXZlcnNSZWYuY3VycmVudCA9IHJpdmVycztcbiAgb25TZWxlY3RSaXZlclJlZi5jdXJyZW50ID0gb25TZWxlY3RSaXZlcjtcbiAgc2VsZWN0ZWRSaXZlcklkUmVmLmN1cnJlbnQgPSBzZWxlY3RlZFJpdmVySWQ7XG4gIGNvbnN0IFttYXBSZWFkeSwgc2V0TWFwUmVhZHldID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IGluaXRNYXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtYXBDb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgbWFwID0gbmV3IG1hcGxpYnJlZ2wuTWFwKHtcbiAgICAgIGNvbnRhaW5lcjogbWFwQ29udGFpbmVyUmVmLmN1cnJlbnQsXG4gICAgICBzdHlsZTogaW5pdGlhbFN0eWxlVXJsID8/IFwiaHR0cHM6Ly9iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vZ2wvdm95YWdlci1nbC1zdHlsZS9zdHlsZS5qc29uXCIsXG4gICAgICBjZW50ZXI6IE1PTlRBTkFfQ0VOVEVSLFxuICAgICAgem9vbTogREVGQVVMVF9aT09NLFxuICAgICAgcGl0Y2g6IDIyLFxuICAgICAgYmVhcmluZzogLTUsXG4gICAgfSk7XG5cbiAgICBtYXAuYWRkQ29udHJvbChuZXcgbWFwbGlicmVnbC5OYXZpZ2F0aW9uQ29udHJvbCgpLCBcInRvcC1yaWdodFwiKTtcbiAgICBtYXBSZWYuY3VycmVudCA9IG1hcDtcblxuICAgIG1hcC5vbihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgbWFwLnJlc2l6ZSgpO1xuICAgICAgc2V0TWFwUmVhZHkodHJ1ZSk7XG4gICAgICBvbk1hcFJlYWR5Py4obWFwKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBtYXAucmVzaXplKCkpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBtYXAucmVzaXplKCksIDEwMCk7XG4gICAgICB0cnkge1xuICAgICAgICBlbnN1cmVSaXZlckxheWVycyhtYXAsIHJpdmVyc1JlZiwgb25TZWxlY3RSaXZlclJlZiwgaG92ZXJJZFJlZiwgc2VsZWN0ZWRSaXZlcklkUmVmKTtcbiAgICAgIH0gY2F0Y2ggeyAvKiBpZ25vcmUgKi8gfVxuICAgIH0pO1xuICB9LCBbb25NYXBSZWFkeV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5pdE1hcCgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtYXBSZWYuY3VycmVudD8ucmVtb3ZlKCk7XG4gICAgICBtYXBSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBsYXN0Rmxvd25SZWYuY3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgfSwgW2luaXRNYXBdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IG1hcFJlZi5jdXJyZW50O1xuICAgIGlmICghbWFwIHx8ICFtYXBDb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4gbWFwLnJlc2l6ZSgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiBtYXAucmVzaXplKCkpO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobWFwQ29udGFpbmVyUmVmLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfSwgW21hcFJlYWR5XSk7XG5cbiAgY29uc3Qgcml2ZXJzS2V5ID0gcml2ZXJzLm1hcCgocikgPT4gci5yaXZlcl9pZCkuam9pbihcIixcIik7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWFwID0gbWFwUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFtYXAgfHwgIW1hcFJlYWR5KSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBtYXAuaXNTdHlsZUxvYWRlZCA9PT0gXCJmdW5jdGlvblwiICYmICFtYXAuaXNTdHlsZUxvYWRlZCgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgZW5zdXJlUml2ZXJMYXllcnMobWFwLCByaXZlcnNSZWYsIG9uU2VsZWN0Uml2ZXJSZWYsIGhvdmVySWRSZWYsIHNlbGVjdGVkUml2ZXJJZFJlZik7XG4gICAgfSBjYXRjaCB7IC8qIGlnbm9yZSAqLyB9XG5cbiAgICBjb25zdCBmYyA9IHJpdmVyc1RvRmVhdHVyZUNvbGxlY3Rpb24ocml2ZXJzKTtcbiAgICBpZiAoZmMuZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSBuZXcgbWFwbGlicmVnbC5MbmdMYXRCb3VuZHMoXG4gICAgICAgIGZjLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gICAgICAgIGZjLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzIGFzIFtudW1iZXIsIG51bWJlcl1cbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgZmMuZmVhdHVyZXMpIGJvdW5kcy5leHRlbmQoZi5nZW9tZXRyeS5jb29yZGluYXRlcyBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgIG1hcC5maXRCb3VuZHMoYm91bmRzLCB7IHBhZGRpbmc6IDYwLCBkdXJhdGlvbjogNDUwIH0pO1xuICAgIH1cbiAgfSwgW3JpdmVyc0tleSwgbWFwUmVhZHksIHJpdmVycywgb25TZWxlY3RSaXZlcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWFwID0gbWFwUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFtYXAgfHwgIW1hcFJlYWR5KSByZXR1cm47XG4gICAgaWYgKCFtYXAuZ2V0TGF5ZXIoU0VMRUNURURfSEFMT19MQVlFUikgfHwgIW1hcC5nZXRMYXllcihTRUxFQ1RFRF9DT1JFX0xBWUVSKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgcmlkID0gc2VsZWN0ZWRSaXZlcklkID8/IFwiX19ub25lX19cIjtcbiAgICB0cnkge1xuICAgICAgbWFwLnNldEZpbHRlcihTRUxFQ1RFRF9IQUxPX0xBWUVSLCBbXCI9PVwiLCBbXCJnZXRcIiwgXCJyaXZlcl9pZFwiXSwgcmlkXSk7XG4gICAgICBtYXAuc2V0RmlsdGVyKFNFTEVDVEVEX0NPUkVfTEFZRVIsIFtcIj09XCIsIFtcImdldFwiLCBcInJpdmVyX2lkXCJdLCByaWRdKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8qIGlnbm9yZSAqL1xuICAgIH1cbiAgfSwgW3NlbGVjdGVkUml2ZXJJZCwgbWFwUmVhZHldKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IG1hcFJlZi5jdXJyZW50O1xuICAgIGlmICghbWFwIHx8ICFtYXBSZWFkeSkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbWFwLmlzU3R5bGVMb2FkZWQgPT09IFwiZnVuY3Rpb25cIiAmJiAhbWFwLmlzU3R5bGVMb2FkZWQoKSkgcmV0dXJuO1xuXG4gICAgY2xlYXJTZWxlY3RlZFJpdmVyTGluZShtYXApO1xuXG4gICAgY29uc29sZS5sb2coXCJbc2VsZWN0ZWRSaXZlckdlb2pzb25dXCIsIHNlbGVjdGVkUml2ZXJHZW9qc29uKTtcblxuICAgIGlmICghc2VsZWN0ZWRSaXZlcklkKSB7XG4gICAgICBsYXN0Rmxvd25SZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsYXN0Rmxvd25SZWYuY3VycmVudCA9PT0gc2VsZWN0ZWRSaXZlcklkKSByZXR1cm47XG4gICAgbGFzdEZsb3duUmVmLmN1cnJlbnQgPSBzZWxlY3RlZFJpdmVySWQ7XG5cbiAgICBjb25zdCBmb2N1czogW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZCA9XG4gICAgICBzZWxlY3RlZFJpdmVyPy5sYXQgIT0gbnVsbCAmJiBzZWxlY3RlZFJpdmVyPy5sbmcgIT0gbnVsbFxuICAgICAgICA/IFtzZWxlY3RlZFJpdmVyLmxuZyEsIHNlbGVjdGVkUml2ZXIubGF0IV1cbiAgICAgICAgOiBSSVZFUl9GT0NVU19QT0lOVFNbc2VsZWN0ZWRSaXZlcklkXTtcblxuICAgIGlmIChzZWxlY3RlZFJpdmVyR2VvanNvbikge1xuICAgICAgYWRkU2VsZWN0ZWRSaXZlckxpbmUobWFwLCBzZWxlY3RlZFJpdmVyR2VvanNvbik7XG4gICAgICBjb25zdCBiYm94ID0gZ2VvanNvbkJib3goc2VsZWN0ZWRSaXZlckdlb2pzb24pO1xuICAgICAgaWYgKGJib3ggJiYgbWFwLmZpdEJvdW5kcykge1xuICAgICAgICBtYXAuZml0Qm91bmRzKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFtiYm94WzBdLCBiYm94WzFdXSxcbiAgICAgICAgICAgIFtiYm94WzJdLCBiYm94WzNdXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIHsgcGFkZGluZzogNjAsIGR1cmF0aW9uOiA3MDAsIGVzc2VudGlhbDogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIG1hcC5mbHlUbyh7XG4gICAgICAgIGNlbnRlcjogZm9jdXMsXG4gICAgICAgIHpvb206IEZMWV9aT09NLFxuICAgICAgICBkdXJhdGlvbjogRkxZX0RVUkFUSU9OLFxuICAgICAgICBjdXJ2ZTogRkxZX0NVUlZFLFxuICAgICAgICBlc3NlbnRpYWw6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtzZWxlY3RlZFJpdmVySWQsIHNlbGVjdGVkUml2ZXJHZW9qc29uLCBzZWxlY3RlZFJpdmVyLCBtYXBSZWFkeV0pO1xuXG4gIC8vIFJlLWFwcGx5IHNlbGVjdGVkIHJpdmVyIGxpbmUgd2hlbiBiYXNlbWFwIGNoYW5nZXMgKG1hcC5zZXRTdHlsZSB3aXBlcyBjdXN0b20gbGF5ZXJzKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IG1hcFJlZi5jdXJyZW50O1xuICAgIGlmICghbWFwIHx8ICFtYXBSZWFkeSkgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVhcHBseSA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFyU2VsZWN0ZWRSaXZlckxpbmUobWFwKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkUml2ZXJHZW9qc29uKSBhZGRTZWxlY3RlZFJpdmVyTGluZShtYXAsIHNlbGVjdGVkUml2ZXJHZW9qc29uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW01hcFZpZXddIHJlYXBwbHkgc2VsZWN0ZWQgcml2ZXIgbGluZSBmYWlsZWRcIiwgZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIG1hcC5vbihcImxvYWRcIiwgcmVhcHBseSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1hcC5vZmYoXCJsb2FkXCIsIHJlYXBwbHkpO1xuICAgIH07XG4gIH0sIFttYXBSZWFkeSwgc2VsZWN0ZWRSaXZlckdlb2pzb25dKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGlkPVwibWFwXCJcbiAgICAgIHJlZj17bWFwQ29udGFpbmVyUmVmfVxuICAgICAgY2xhc3NOYW1lPXtgYWJzb2x1dGUgaW5zZXQtMCB3LWZ1bGwgaC1mdWxsIG1pbi1oLTAgWyZfLm1hcGxpYnJlZ2wtbWFya2VyXTpjdXJzb3ItcG9pbnRlciAke2NsYXNzTmFtZSA/PyBcIlwifWAudHJpbSgpfVxuICAgICAgYXJpYS1sYWJlbD1cIk1vbnRhbmEgcml2ZXIgbWFwXCJcbiAgICA+XG4gICAgICB7bWFwUmVhZHkgJiYgbWFwUmVmLmN1cnJlbnQgJiYgPE1hcENvbnRyb2xzIG1hcD17bWFwUmVmLmN1cnJlbnR9IC8+fVxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VTdGF0ZSIsIm1hcGxpYnJlZ2wiLCJSSVZFUl9GT0NVU19QT0lOVFMiLCJNYXBDb250cm9scyIsIk1PTlRBTkFfQ0VOVEVSIiwiREVGQVVMVF9aT09NIiwiRkxZX1pPT00iLCJGTFlfRFVSQVRJT04iLCJGTFlfQ1VSVkUiLCJCSVRFX1RJRVJfQ09MT1JTIiwiSE9UIiwiR09PRCIsIkZBSVIiLCJUT1VHSCIsIlJJVkVSX0xJTkVfU09VUkNFIiwiUklWRVJfTElORV9MQVlFUiIsIlJJVkVSU19TT1VSQ0UiLCJVTkNMVVNURVJFRF9MQVlFUiIsIlNFTEVDVEVEX0hBTE9fTEFZRVIiLCJTRUxFQ1RFRF9DT1JFX0xBWUVSIiwibm9ybWFsaXplR2VvanNvbiIsImciLCJ0eXBlIiwicHJvcGVydGllcyIsImdlb21ldHJ5IiwiYWRkU2VsZWN0ZWRSaXZlckxpbmUiLCJtYXAiLCJnZW9qc29uIiwiZGF0YSIsImdldExheWVyIiwicmVtb3ZlTGF5ZXIiLCJnZXRTb3VyY2UiLCJyZW1vdmVTb3VyY2UiLCJhZGRTb3VyY2UiLCJhZGRMYXllciIsImlkIiwic291cmNlIiwibGF5b3V0IiwicGFpbnQiLCJsYXllcnMiLCJnZXRTdHlsZSIsImxlbmd0aCIsIm1vdmVMYXllciIsImNsZWFyU2VsZWN0ZWRSaXZlckxpbmUiLCJnZW9qc29uQmJveCIsImNvb3JkcyIsImNvbGxlY3QiLCJwdXNoIiwiY29vcmRpbmF0ZXMiLCJjIiwibGluZSIsInJpbmciLCJmIiwiZmVhdHVyZXMiLCJsb25zIiwibGF0cyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJyaXZlcnNUb0ZlYXR1cmVDb2xsZWN0aW9uIiwicml2ZXJzIiwicml2ZXIiLCJsYXQiLCJsYXRpdHVkZSIsImxuZyIsImxvbmdpdHVkZSIsInJpdmVyX2lkIiwicml2ZXJfbmFtZSIsImJpdGVfdGllciIsImZpc2hhYmlsaXR5X3Njb3JlIiwiZmlzaGFiaWxpdHlfc2NvcmVfY2FsYyIsImVuc3VyZVJpdmVyTGF5ZXJzIiwicml2ZXJzUmVmIiwib25TZWxlY3RSaXZlclJlZiIsImhvdmVySWRSZWYiLCJzZWxlY3RlZFJpdmVySWRSZWYiLCJjdXJyZW50IiwiZmMiLCJzcmMiLCJjbHVzdGVyIiwiZ2VuZXJhdGVJZCIsInNldERhdGEiLCJmaWx0ZXIiLCJfX21yaUhhbmRsZXJzIiwib24iLCJlIiwicmlkIiwiZmluZCIsInIiLCJnZXRDYW52YXMiLCJzdHlsZSIsImN1cnNvciIsInNldEZlYXR1cmVTdGF0ZSIsImhvdmVyIiwic2V0RmlsdGVyIiwiTWFwVmlldyIsInNlbGVjdGVkUml2ZXIiLCJzZWxlY3RlZFJpdmVySWQiLCJzZWxlY3RlZFJpdmVyR2VvanNvbiIsIm9uU2VsZWN0Uml2ZXIiLCJjbGFzc05hbWUiLCJpbml0aWFsU3R5bGVVcmwiLCJvbk1hcFJlYWR5IiwibWFwQ29udGFpbmVyUmVmIiwibWFwUmVmIiwibGFzdEZsb3duUmVmIiwibWFwUmVhZHkiLCJzZXRNYXBSZWFkeSIsImluaXRNYXAiLCJNYXAiLCJjb250YWluZXIiLCJjZW50ZXIiLCJ6b29tIiwicGl0Y2giLCJiZWFyaW5nIiwiYWRkQ29udHJvbCIsIk5hdmlnYXRpb25Db250cm9sIiwicmVzaXplIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsInJlbW92ZSIsImhhbmRsZVJlc2l6ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0Iiwicml2ZXJzS2V5Iiwiam9pbiIsImlzU3R5bGVMb2FkZWQiLCJib3VuZHMiLCJMbmdMYXRCb3VuZHMiLCJleHRlbmQiLCJmaXRCb3VuZHMiLCJwYWRkaW5nIiwiZHVyYXRpb24iLCJjb25zb2xlIiwibG9nIiwiZm9jdXMiLCJiYm94IiwiZXNzZW50aWFsIiwiZmx5VG8iLCJjdXJ2ZSIsInJlYXBwbHkiLCJ3YXJuIiwib2ZmIiwiZGl2IiwicmVmIiwidHJpbSIsImFyaWEtbGFiZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/MapView.tsx\n"));

/***/ })

});